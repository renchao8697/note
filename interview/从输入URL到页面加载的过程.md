# 从输入URL到页面加载的过程

## 对知识体系的评级
#### level1：
完全没有什么概念，大概如下回答：
* 浏览器发起请求，服务端返回数据，然后前端解析成网页，执行脚本。。。
#### level2：
已经有初步概念，但是没有完整梳理过，导致无法形成一个完整的体系，或者是很多细节都不会展开，大概如下回答：
* 知道浏览器输入url后会有http请求这个概念
* 有后台这个概念，大致知道前后端的交互，知道前后端主要靠http报文通信
* 知道浏览器接收到数据后会进行解析，有一定概念，但是具体流程不熟悉（如render树构建流程，layout、paint，复合层与简单层，常用优化方案等不是很熟悉）
* 对于js引擎的解析流程有一定概念，但是细节不熟悉（如具体的形参，函数，变量提升，执行上下文以及VO、AO、作用域链，回收机制等概念不是很熟悉）
* 可能知道一些http规范初步概念，但是不熟悉（如http报文结构，常用头部，缓存机制，http2.0，https等特性，跨域与web安全等不是很熟悉）
#### level3：
基本能到这一步的，不是高阶就是接近高阶，因为很多概念并不是靠背就能理解的，而是要理解这么多，需形成体系，一般需要积累，非一日之功。
大概如下回答：
* 首先略去那些键盘输入和操作系统交互、以及屏幕显示原理、网卡等硬件交互之类的（前端向中，很多硬件原理暂时略去）
* 对浏览器模型有整体概念，知道浏览器是多进程的，浏览器内核是多线程的，清楚进程与线程之间的区别，以及输入url后会开一个新的网络线程
* 对于开启网络线程到发出一个完整的http请求中间的过程有所了解（如dns查询，tcp/ip连接，五层因特网协议栈等等，以及一些优化方案，如dns-prefetch）
* 对从服务器接收到请求到对应后台接收到请求有一定了解（如负载均衡，安全拦截以及后台代码处理等）
* 对后台和前台的http交互熟悉（包括http报文结构，场景头部，cookie，跨域，web安全，http缓存，http2.0，https等）
* 对浏览器接收到http数据包后的解析流程熟悉（包括解析html，词法分析然后解析成dom树、解析css生成css规则树、合并成render树，然后layou、painting渲染、里面可能还包括复合图层的合成、GPU绘制、外链处理、加载顺序等）
* 对js引擎解析过程熟悉（包括js的解释，预处理，执行上下文，VO，作用域链，this，回收机制等）
#### level4：
大概会有如下回答（猜的）：
* 从键盘谈到系统交互，从浏览器到CPU，从调度机制到系统内核，从数据请求到二进制、汇编，从GPU绘图到LCD显示，然后在分析系统底层的进程、内存等等。

## 梳理主干流程
知识体系中，最重要的就是骨架，脉络。有了骨架后才方便填充细节。所有先梳理下主干流程：
1. 从浏览器接收url到开启网络请求线程（这一部分可以展开浏览器的机制以及展开浏览器的机制以及进程与线程之间的关系）
2. 开启网络线程到发出一个完整的http请求（这一部分涉及到dns查询，tcp/ip请求，五层因特网协议栈等知识）
3. 从服务器接收到请求到对应后台接收到请求（这一部分可能涉及到负载均衡，安全拦截以及后台内部的处理等等）
4. 后台和前台的http交互（这一部分包括头部、响应码、报文结构、cookie等知识，可以提下静态资源的cookie优化，以及编码解码，如gzip压缩等）
5. 单独拎出来的缓存问题，http的缓存（这部分包括http缓存头部，etag，catch-control等）
6. 浏览器接收到http数据包后的解析流程（解析html-词法分析然后解析成dom树、解析css生层css规则树、合成render树，然后layout、painting渲染、复合图层的合成、GPU绘制、外链资源的处理、loaded和domcontentloaded等）
7. CSS的可视化格式模型（元素的渲染规则，如包含块，控制框，BFC，IFC等概念）
8. JS引擎解析过程（JS的解释阶段，预处理阶段，执行阶段生成执行上下文，VO，作用域链、回收机制等等）
9. 其他（可以拓展不同的知识模块，如跨域，web安全，hybrid模式等等内容）
梳理出主干骨架，然后就需要往骨架上填充细节内容

## 从浏览器接收url到开启网络请求线程
这一部分展开的内容是：浏览器进程/线程模型，JS的运行机制

### 多进程的浏览器
浏览器是多进程的，有一个主控进程，以及每一个tab页面都会新开一个进程（某些情况下多个会合并进程）
进程可能包括主控进程，插件进程，GPU，tab页（浏览器内核）等等
* Browser进程：浏览器的主进程（负责协调、主控），只有一个
* 第三方插件进程：没中类型的插件对应一个进程，仅当使用该插件时才会创建
* GPU进程：最多一个，用于3D绘制
* 浏览器渲染进程（内核）：默认每个tab页面一个进程，互不影响，控制页面渲染，脚本执行，时间处理等（有时候会优化，如多个空白tab会合并成一个进程）
  
如下图：
![browser](./images/browser.png)

### 多线程的浏览器内核
每个tab页面可以看作是浏览器内核进程，然后这个进程是多线程的，它有几大类子线程
* GUI线程
* JS引擎线程
* 事件触发线程
* 定时器线程
* 网络请求线程
  
![browser_kernel](./images/browser_kernel.png)
可以看到，里面的JS引擎是内核进程中的一个线程，这也是为什么常说JS引擎是单线程的

### 解析URL
输入URL后，会进行解析（URL的本质就是统一资源定位符）
URL一般包括几大部分：
* `protocol`，协议头，譬如有http，ftpdeng
* `host`，主机域名或IP地址
* `port`，端口号
* `path`，目录路径
* `query`，查询参数
* `fragment`，即`#`后的hash值，一般用来定位到某个位置

### 网络请求都是单独的线程
每次网络请求时都需要开辟单独的线程进行，譬如如果URL解析到http协议，就会新建一个网络线程去处理资源下载，因此浏览器会根据解析出得协议，开辟一个网络线程，前往请求资源（这里，暂时理解为时浏览器内核开辟的，如有错误，后续修复）

## 开启网络线程到发出一个完整的http请求
这一部分主要内容包括：`dns`查询，`tcp/ip`请求构建，`五层因特网协议栈`等等

### DNS查询得到IP
如果输入的是域名，需要进行`dns`解析成`IP`，大致流程：
* 如果浏览器有缓存，直接使用浏览器缓存，否则使用本机缓存，再没有的话就使用host
* 如果本地没有，就想dns域名服务器查询（中间可能还会经过路由，也有缓存等），查询到对应的IP

注意，域名查询时有可能是经过了CDN调度器的（如果有cdn储存功能的话）
而且，需要知道dns解析是很耗时的，因此如果解析域名过多，会让首屏加载变得过慢，可以考虑`dns-prefetch`优化

### tcp/ip请求
http的本质就是tcp/ip请求
需要了解3次握手规则建立连接以及断开连接时的四次挥手
tcp将http长报文划分为短报文，通过三次握手与服务端建立连接，进行可靠传输

#### 三次握手的步骤：
> 客户端：hello，你是server吗？
> 服务端：hello，我是server，你是client吗?
> 客户端：yes，我是client

建立连接成功后，接下来就正式传输数据
然后，待到断开连接时，需要进行四次挥手

#### 四次挥手的步骤：
> 主动方：我已经关闭了向你那边的主动通道，只能被动接收了
> 被动方：收到通道关闭的信息
> 被动方：那我也告诉你 ，我这边向你的主动通道也关闭了
> 主动方：收到数据，之后双方无法通信

#### tcp/ip的并发限制
浏览器对同一域名下并发的tcp连接是有限制的（2-10个不等）
而且在http1.0中往往一个资源下载就需要对应一个tcp/ip请求
所以针对这个瓶颈，又出现了很多的资源优化方案

#### get和post的区别
get和post虽然本质都是tcp/ip，但是两个除了在http层面外，在tcp/ip层面也有区别。
get会产生一个tcp数据包，post两个，具体为：
* get请求时，浏览器会把`header`和`data`一起发送出去，服务器响应200（返回数据）
* post请求时，浏览器先发送`headers`，服务器响应`100 continue`

浏览器在发送`data`，服务器响应200（返回数据）
再说一点，这里的区别是`specification`（规范）层面，而不是`implementation`（对规范的实现）

### 五层因特网协议栈
可以记不全，但是要有一个整体概念
其实就是一个概念：**从客户端发出http请求到服务器接收，中建会经过一系列的流程。**

简括就是：
**从应用层的发送http请求，到传输层通过三次握手建立tcp/ip连接，再到网络层的ip寻址，再到数据链路层的封装成帧，最后到物理层的利用物理介质传输。**

当然，服务端的接收就是反过来的步骤

五层因特网协议栈其实就是：
> 1. 应用层（dns，http）DNS解析成IP并发送http请求
> 2. 传输层（tcp，udp）建立tcp连接（三次握手）
> 3. 网络层（IP，ARP）IP寻址
> 4. 数据链路层（PPP）封装成帧
> 5. 物理层（利用物理介质传输比特流）物理传输（然后传输的时候通过双绞线，电磁波等各种介质）

当然，其实也有一个完整的OSI七层框架，与之相比，多了会话层、表示层。
OSI七层框架：`物理层`、`数据链路层`、`网络层`、`传输层`、`会话层`、`表示层`、`应用层`
> 表示层：主要处理两个通信系统中交换信息的表示方式，包括数据格式交换，数据加密与解密，数据压缩与终端类型转换等
> 会话层：它具体管理不同用户和进程之间的对话，如控制登录和注销过程

## 从服务器接收到请求到对应后台接收到请求
服务端在接收到请求时，内部会进行很多的处理
这里由于不是专业的后端分析，所以只是简单的介绍下

### 负载均衡
对于大型的项目，由于并发访问量很大，所以往往一台服务器是吃不消的，所以一般会有若干台服务器组成一个集群，然后配合方向代理实现负载均衡

简单的说：
**用户发起的请求都指向调度服务器（反向代理服务器，譬如安装nginx控制负载均衡），然后调度服务器根据实际的调度算法，分配不同的请求给对应集群中的服务器执行，然后调度器等待实际服务器的HTTP响应，并将它反馈给用户**

### 后台的处理
一般后台都是部署到容器中的，所以一般为：
* 先是容器接受到请求（如tomcat容器）
* 然后对应容器中的后台程序接受到请求（如java程序）
* 然后就是后台会有自己统一处理，处理完后响应响应结果

概括下：
* 一般有的后端是有统一的验证的，如安全拦截，跨域验证
* 如果这一步不符合规则，就直接返回相应的http报文（如拒绝请求等）
* 然后当验证通过后，才会进入实际的后台代码，此时是程序接收到请求，然后执行（譬如查询数据库，大量计算等等）
* 等程序执行完毕后，就会返回一个http响应包（一般这一步也会经过多层封装）
* 然后就是将这个包从后端发送到前端，完成交互

### 后台和前台的http交互
前后端交互时，http报文作为信息的载体
所以http是一块很重要的内容，这一部分重点介绍它

#### http报文结构
报文一般包括了：`通用头部`，`请求/响应头部`，`请求/响应体`

##### 通用头部
这也是开发人员见过最多的信息，包括如下：
> Request Url：请求的web服务器地址
> Request Method： 请求方式（GET、POST、OPTIONS、PUT、HEAD、DELETE、CONNECT、TRACE）
> Status Code：请求的返回状态码，如200代表成功
> Remote Address：请求的远程服务器地址（会转为IP）

譬如，在跨域拒绝时，可能是method为`options`，状态码为`404/405`等（当然，实际上可能的组合有很多）

其中，method的话一般分为两批次：
> HTTP1.0定义了三种请求方法：GET，POST和HEAD方法。
> 以及几种Additional Request Methods：PUT、DELETE、LINK、UNLINK
> HTTP1.1定义了八种请求方法：GET、POST、HEAD、OPTIONS、PUT、DELETE、TRACE和CONNECT方法。

这里面最常用到的就是状态码，很多时候都是通过状态码来判断，如（列举几个最常见的）：
> 200 表明该请求被成功地完成，所有请求的资源发送回客户端
> 304 自从上次请求后，请求的网页未修改过，请客户端使用本地缓存
> 400 客户端请求有错（譬如可以是安全模块拦截）
> 401 请求未经授权
> 403 禁止访问（譬如可以是未登录时禁止）
> 404 资源未找到
> 500 服务器内部错误
> 503 服务不可用
> ...

在列举下大致不同范围状态的意义
> 1xx 指示信息，表示请求已接收，继续处理
> 2xx 成功，表示请求已被成功接收、理解、接受
> 3xx 重定向，要完成请求必须进行更进一步的操作
> 4xx 客户端错误，请求有语法错误或请求无法实现
> 5xx 服务器端错误，服务器端未能实现合法的请求

![http_status](./images/http_status.png)

总之，请求出错时，状态码能帮助快速定位问题。

##### 请求/响应头部
请求和响应头部也是分析时常用到的
常用的请求头部（部分）：
> Accept：接收类型，表示浏览器支持的MIME类型（对标服务端返回的Content-Type）
> Accept-Encoding：浏览器支持的压缩类型，如gzip等，超出类型不能接收
> Content-Type：客户端发送出去实体内容的类型
> Cache-Control：指定请求和响应遵循的缓存机制，如no-cache
> If-Modified-Since：对应服务端的Last-Modified，用来匹配看文件是否变动，只能精确到1s之内，http1.0中
> Expires：缓存控制，在这个时间内不会请求，直接使用缓存，http1.0，而且是服务端时间
> Max-age：代表资源再本地缓存多少秒，有效时间内不会请求，而是使用缓存，http1.1中
> If-None-Match：对应服务端的ETag，用来匹配文件内容是否改变（非常精确），http1.1中
> Cookie：有cookie并且同域访问会自动带上
> Connection：当浏览器与服务器通信时对于长连接如何进行处理，如keep-alive
> Host：请求的服务器URL
> Origin：最初的请求是从哪里发起的（只会精确到端口），Origin比Referer更尊重隐私
> Referer：该页面的来源URL（适用于所有类型的请求，会精确到详细页面地址，csrf拦截常用到这个字段）
> User-Agent：用户客户端的一些必要信息，如UA头部等

常用的响应头部（部分）：
> Access-Control-Allow-Headers：服务器端允许的请求Headers
> Access-Control-Allow-Methods：服务端允许的请求方法
> Access-Control-Allow-Origin：服务器端允许的请求Origin头部（譬如为*）
> Content-Type：服务端返回的实体内容的类型
> Date：数据从服务器发送的时间
> Cache-Control：告诉浏览器或者其他用户，什么环境可以安全缓存文档
> Last-Modified：请求资源的最后修改时间
> Expires：应该在什么时候任务文档已经过期，从而不再缓存它
> Max-age：客户端的本地资源应该缓存多少秒，开启了Cache-Control后有效
> ETag：请求变量的实体标签的当前值
> Set-Cookie：设置和页面关联的cookie，服务器通过这个头部把cookie传给客户端
> Keep-Alive：如果客户端有keep-alive，服务端也会有相应（如timeout=38）
> Server：服务器的一些相关信息

一般来说，请求头部和响应头部是匹配分析的。
譬如请求头部的`Accept`要和响应头部的`Content-Type`匹配，否则会报错
譬如，跨域请求时，请求头部的`Origin`要匹配响应头部的`Access-Control-Allow-Origin`，否则会报跨域错误
譬如，在使用缓存时，请求头部的`If-Modified-Since`、`If-None-Match`分别和响应头部的`Last-Modified`、`ETag`对应

##### 请求/响应实体
http请求时，除了头部，还有消息实体，一般来说
请求实体中会将一些需要的参数都放入进入（用于post请求）。
譬如实体中可以放参数的序列化形式（a=1&b=2这种），或者直接放表单对象（Form Data对象，上传时可以夹杂参数以及文件），等等。
而一般响应实体中，就是放服务端需要传给客户端的内容
一般现在的借口请求时，实体中就是对应信息的json格式，而像页面请求这种，里面就是直接放了一个html字符串，然后浏览器自己解析并渲染。

##### CRLF
CRLF（Carriage-Return Line-Feed），意思是回车换行，一般作为分隔符存在
请求头和实体消息之间有一个CRLF分隔，响应头部和响应实体之间用一个CRLF分隔
一般来说（分隔符类别）：
> CRLF -> windows-style
> LF -> Unix style
> CR -> Mac Style

如下图是对某请求的http报文结构的建哟啊分析
![http_headers](./images/http_headers.jpg)