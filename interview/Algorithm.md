#### 两数之和
*LeetCode1 简单*
*Tags: array | hash-table*

给定一个整数数组`nums`和一个整数目标值`target`，请你在该数组中找出**和为目标值**`target`的那**两个**整数，并返回它们的数组下标。
你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。
你可以按任意顺序返回答案。

示例1：
> 输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1]

示例2：
> 输入：nums = [3,2,4], target = 6
输出：[1,2]

示例3：
> 输入：nums = [3,3], target = 6
输出：[0,1]

答案1：暴力枚举
**思路**
枚举数组中的每一个数`x`，寻找数组中是否存在`target-x`；双层循环，第一层循环取`x`，第二层循环在数组中找`target-x`，第二次循环只需要找x之后的元素就可以了。
```js 
const twoSum = (nums, target) => {
    for(let i = 0; i < nums.length; i++) {
        for (let j = i + 1; j < nums.length; j++) {
            if (nums[i] + nums[j] === target) {
                return [i, j];
            }
        }
    }
};
```
* 时间复杂度：O($N^{2}$)
* 空间复杂度：O(1)

答案2：哈希表
**思路**
创建一个哈希表，对于每一个x，首先查询哈希表中是否存在target-x，存在即得到答案，不存在则继续遍历。
```js 
const twoSum = (nums, target) => {
    let cache = {};
    for(let i = 0; i < nums.length; i++) {
        if ((target - nums[i]) in cache) {
            return [cache[target - nums[i]], i];
        } else {
            cache[nums[i]] = i;
        }
    }
};
```
* 时间复杂度：O(N)
* 空间复杂度：O(N)

#### 斐波那契数
*LeetCode509 简单*
*Tags: tree*

斐波那契数，通常用`F(n)`表示，形成的序列称为**斐波那契数列**。该数列由`0`和`1`开始，后面的每一项数字都是前面两项数字的和。也就是：
> F(0) = 0，F(1) = 1
F(n) = F(n - 1) + F(n - 2)，其中 n > 1

给你`n`，请计算`F(n)`。

实例1：
> 输入：2
输出：1
解释：F(2) = F(1) + F(0) = 1 + 0 = 1

实例2：
> 输入：3
输出：2
解释：F(3) = F(2) + F(1) = 1 + 1 = 2

实例3：
> 输入：4
输出：3
解释：F(4) = F(3) + F(2) = 2 + 1 = 3

答案1：递归
```js
const fib = n => n <= 1 ? n : fib(n - 1) + fib(n - 2);
```

答案2：递推
```js
const fib = (n) => {
    let arr = [];
    for (let i = 0; i <= n; i++) {
        if (i <= 1) {
            arr.push(i);
        } else {
            arr.push(arr[i - 1] + arr[i - 2]);
        }
    }
    return arr.pop();
}
```
* 时间复杂度：O(n)
* 空间复杂度：O(n)

答案2：动态规划
**思路**
斐波那契数的边界条件是`F(0)=0`和`F(1)=1`。当`n>1`时每一项的和都是等于前两项的和，因此有如下递推关系：`F(n)=F(n-1)+F(n-2)`
由于斐波那契数存在递推关系，因此可以使用动态规划求解。动态规划的状态转移方程即为上述递推关系，边界条件`F(0)`和`F(1)`。
根据状态转移方程和边界条件，可以得到时间复杂度和空间复杂度都是`O(n)`的实现。由于`F(n)`只和`F(n-1)`与`F(n-2)`有关，因此可以使用【滚动数组思想】把空间复杂度优化成`O(1)`。

```js
const fib = (n) => {
    if (n <= 1) {
        return n;
    }
    let [p, q, r] = [0, 0, 1];
    for (let i = 2; i <= n; i++) {
        [p, q, r] = [q, r, q + r];
    }
    return r;
}
```
* 时间复杂度：O(n)
* 空间复杂度：O(1)