#### 两数之和
*LeetCode1 简单*
*Tags: array | hash-table*

给定一个整数数组`nums`和一个整数目标值`target`，请你在该数组中找出**和为目标值**`target`的那**两个**整数，并返回它们的数组下标。
你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。
你可以按任意顺序返回答案。

```
示例1：
输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1]

示例2：
输入：nums = [3,2,4], target = 6
输出：[1,2]

示例3：
输入：nums = [3,3], target = 6
输出：[0,1]
```


答案1：暴力枚举
**思路**
枚举数组中的每一个数`x`，寻找数组中是否存在`target-x`；双层循环，第一层循环取`x`，第二层循环在数组中找`target-x`，第二次循环只需要找x之后的元素就可以了。
```js 
const twoSum = (nums, target) => {
    for(let i = 0; i < nums.length; i++) {
        for (let j = i + 1; j < nums.length; j++) {
            if (nums[i] + nums[j] === target) {
                return [i, j];
            }
        }
    }
};
```
* 时间复杂度：O($N^{2}$)
* 空间复杂度：O(1)

答案2：哈希表
**思路**
创建一个哈希表，对于每一个x，首先查询哈希表中是否存在target-x，存在即得到答案，不存在则继续遍历。
```js 
const twoSum = (nums, target) => {
    let cache = {};
    for(let i = 0; i < nums.length; i++) {
        if ((target - nums[i]) in cache) {
            return [cache[target - nums[i]], i];
        } else {
            cache[nums[i]] = i;
        }
    }
};
```
* 时间复杂度：O(N)
* 空间复杂度：O(N)

#### 斐波那契数
*LeetCode509 简单*
*Tags: tree*

斐波那契数，通常用`F(n)`表示，形成的序列称为**斐波那契数列**。该数列由`0`和`1`开始，后面的每一项数字都是前面两项数字的和。也就是：
> F(0) = 0，F(1) = 1
> 
> F(n) = F(n - 1) + F(n - 2)，其中 n > 1

给你`n`，请计算`F(n)`。

```
示例1：
输入：2
输出：1
解释：F(2) = F(1) + F(0) = 1 + 0 = 1

示例2：
输入：3
输出：2
解释：F(3) = F(2) + F(1) = 1 + 1 = 2

示例3：
输入：4
输出：3
解释：F(4) = F(3) + F(2) = 2 + 1 = 3
```

答案1：递归
```js
const fib = n => n <= 1 ? n : fib(n - 1) + fib(n - 2);
```

答案2：递推
```js
const fib = (n) => {
    let arr = [];
    for (let i = 0; i <= n; i++) {
        if (i <= 1) {
            arr.push(i);
        } else {
            arr.push(arr[i - 1] + arr[i - 2]);
        }
    }
    return arr.pop();
}
```
* 时间复杂度：O(n)
* 空间复杂度：O(n)

答案2：动态规划
**思路**
斐波那契数的边界条件是`F(0)=0`和`F(1)=1`。当`n>1`时每一项的和都是等于前两项的和，因此有如下递推关系：`F(n)=F(n-1)+F(n-2)`
由于斐波那契数存在递推关系，因此可以使用动态规划求解。动态规划的状态转移方程即为上述递推关系，边界条件`F(0)`和`F(1)`。
根据状态转移方程和边界条件，可以得到时间复杂度和空间复杂度都是`O(n)`的实现。由于`F(n)`只和`F(n-1)`与`F(n-2)`有关，因此可以使用【滚动数组思想】把空间复杂度优化成`O(1)`。

```js
const fib = (n) => {
    if (n <= 1) {
        return n;
    }
    let [p, q, r] = [0, 0, 1];
    for (let i = 2; i <= n; i++) {
        [p, q, r] = [q, r, q + r];
    }
    return r;
}
```
* 时间复杂度：O(n)
* 空间复杂度：O(1)

#### 有效的括号
*LeetCode20 简单*
*Tags: string | stack*

给定一个只包括`'('`，`')'`，`'{'`，`'}'`，`'['`，`']'` 的字符串`s`，判断字符串是否有效。

有效字符串需满足：
左括号必须用相同类型的右括号闭合。
左括号必须以正确的顺序闭合。

```
示例1：
输入：s = "()"
输出：true

示例2：
输入：s = "()[]{}"
输出：true

示例 3：
输入：s = "(]"
输出：false

示例 4：
输入：s = "([)]"
输出：false

示例 5：
输入：s = "{[]}"
输出：true
```

答案：栈
**思路**
判断括号的有效性可以使用【栈】这一数据结构来解决。
遍历给定的字符串`s`。当遇到一个左括号时，我们会期望在后续的遍历中，有一个相同类型的右括号将其闭合。由于**后遇到的左括号要先闭合**，因此我们可以将这个左括号放入栈顶。
当我们遇到一个右括号时，我们需要将一个相同类型的左括号闭合。此时，我们可以取出栈顶的左括号并判断它们是否是相同类型的括号。如果不是相同的类型，或者栈中并没有左括号，那么字符串`s`无效，返回`false`。为了快速判断括号的类型，我们可以使用哈希表存储每一种括号的对应关系。
在遍历结束后，如果栈不为空，返回`false`，否则返回`true`。
遍历前，可以先判断`s`的长度是否为偶数，如果长度是奇数，则直接返回`false`。

```js
const isValid = (s) => {
    if (s.length % 2) {
        return false;
    }
    let stack = [];
    let map = new Map([['(', ')'], ['[', ']'], ['{', '}']]);
    for (let i = 0; i < s.length; i++) {
        if (map.has(s[i])) {
            stack.push(s[i]);
        } else {
            if (map.get(stack.pop()) === s[i]) {
                continue;
            } else {
                return false;
            }
        }
    }
    return stack.length === 0;
};
```